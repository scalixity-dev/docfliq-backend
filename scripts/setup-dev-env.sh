#!/usr/bin/env bash
# scripts/setup-dev-env.sh
# ---------------------------------------------------------------------------
# One-command dev environment bootstrap.
#
# Reads shared AWS credentials from .env.dev, fetches the RDS password from
# Secrets Manager, and writes a fully-populated .env file.
#
# New developer onboarding:
#   1. Get .env.dev from your team lead (Slack / 1Password / etc.)
#   2. Place it in the repo root
#   3. make install-dev
#   4. make setup-env        ← runs this script
#
# Usage:
#   ./scripts/setup-dev-env.sh          # skips if .env already exists
#   ./scripts/setup-dev-env.sh --force  # overwrites existing .env
# ---------------------------------------------------------------------------
set -euo pipefail

REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
ENV_FILE="$REPO_ROOT/.env"
ENV_DEV="$REPO_ROOT/.env.dev"

SECRET_ARN="arn:aws:secretsmanager:ap-south-1:692454933017:secret:rds!db-d9533535-7d7d-4c23-a10e-3d6dacb93586-QENbin"
RDS_HOST="devpostgres.c9p1ihxwaj4k.ap-south-1.rds.amazonaws.com"
RDS_PORT="5432"
RDS_USER="postgres"
AWS_REGION="ap-south-1"

# ── Helpers ───────────────────────────────────────────────────────────────────
log() { echo "[setup-dev-env] $*"; }
err() { echo "[setup-dev-env] ERROR: $*" >&2; exit 1; }

# ── Guard: skip if .env already exists ───────────────────────────────────────
if [[ -f "$ENV_FILE" && "${1:-}" != "--force" ]]; then
  log ".env already exists. Pass --force to overwrite."
  exit 0
fi

# ── Load shared AWS credentials from .env.dev ─────────────────────────────────
[[ -f "$ENV_DEV" ]] || err ".env.dev not found.\n  Copy the template:  cp .env.dev.example .env.dev\n  Then fill in the AWS credentials (get from team lead)."

# Source only the two AWS keys — ignore everything else in the file
while IFS='=' read -r key value; do
  [[ "$key" =~ ^#.*$ || -z "$key" ]] && continue
  case "$key" in
    AWS_ACCESS_KEY_ID|AWS_SECRET_ACCESS_KEY)
      export "$key"="$value"
      ;;
  esac
done < "$ENV_DEV"

[[ -n "${AWS_ACCESS_KEY_ID:-}"     ]] || err "AWS_ACCESS_KEY_ID missing in .env.dev"
[[ -n "${AWS_SECRET_ACCESS_KEY:-}" ]] || err "AWS_SECRET_ACCESS_KEY missing in .env.dev"

# ── Resolve aws + jq binaries ────────────────────────────────────────────────
AWS_BIN="$REPO_ROOT/.venv/bin/aws"
[[ -f "$AWS_BIN" ]] || AWS_BIN="$(command -v aws 2>/dev/null)" \
  || err "aws CLI not found. Run: make install-dev"
command -v jq &>/dev/null || err "jq not found. Install: sudo apt install jq -y"

# ── Verify the IAM credentials work ──────────────────────────────────────────
log "Verifying AWS credentials..."
IDENTITY=$("$AWS_BIN" sts get-caller-identity --region "$AWS_REGION" --output json 2>&1) \
  || err "AWS credentials invalid or expired. Check .env.dev values."
log "Authenticated as: $(echo "$IDENTITY" | jq -r '.Arn')"

# ── Fetch RDS password from Secrets Manager ───────────────────────────────────
log "Fetching RDS password from Secrets Manager..."
SECRET_JSON=$("$AWS_BIN" secretsmanager get-secret-value \
  --secret-id "$SECRET_ARN" \
  --region "$AWS_REGION" \
  --query SecretString \
  --output text) || err "Failed to fetch secret. Check IAM permissions for this user."

RDS_PASSWORD=$(echo "$SECRET_JSON" | jq -r '.password') \
  || err "Could not parse .password from secret JSON"
[[ -n "$RDS_PASSWORD" ]] || err "Password was empty — check the secret structure"

# ── Write .env ────────────────────────────────────────────────────────────────
log "Writing $ENV_FILE ..."

cat > "$ENV_FILE" <<EOF
# Auto-generated by scripts/setup-dev-env.sh — do not commit
# Re-run to refresh:  make setup-env --force

# ── PostgreSQL (AWS RDS dev) ──────────────────────────────────────────────────
POSTGRES_HOST=${RDS_HOST}
POSTGRES_PORT=${RDS_PORT}
POSTGRES_USER=${RDS_USER}
POSTGRES_PASSWORD=${RDS_PASSWORD}

RDS_SSL_CERT=.certs/global-bundle.pem

IDENTITY_DATABASE_URL=postgresql+asyncpg://${RDS_USER}:${RDS_PASSWORD}@${RDS_HOST}:${RDS_PORT}/identity_db
CONTENT_DATABASE_URL=postgresql+asyncpg://${RDS_USER}:${RDS_PASSWORD}@${RDS_HOST}:${RDS_PORT}/content_db
COURSE_DATABASE_URL=postgresql+asyncpg://${RDS_USER}:${RDS_PASSWORD}@${RDS_HOST}:${RDS_PORT}/course_db
PAYMENT_DATABASE_URL=postgresql+asyncpg://${RDS_USER}:${RDS_PASSWORD}@${RDS_HOST}:${RDS_PORT}/payment_db
PLATFORM_DATABASE_URL=postgresql+asyncpg://${RDS_USER}:${RDS_PASSWORD}@${RDS_HOST}:${RDS_PORT}/platform_db

# ── Redis ─────────────────────────────────────────────────────────────────────
REDIS_URL=redis://localhost:6379/0

# ── JWT ───────────────────────────────────────────────────────────────────────
JWT_SECRET=your-jwt-secret-change-in-production
JWT_ALGORITHM=HS256
JWT_ISSUER=docfliq-identity
JWT_AUDIENCE=docfliq-services

# ── AWS (loaded from .env.dev at runtime for CLI tools) ───────────────────────
AWS_REGION=${AWS_REGION}
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=

# ── OpenSearch (local Docker via make docker-up) ─────────────────────────────
OPENSEARCH_ENABLED=true
OPENSEARCH_URL=http://localhost:9200
OPENSEARCH_INDEX_PREFIX=docfliq
OPENSEARCH_AUTH_MODE=basic
OPENSEARCH_AWS_REGION=${AWS_REGION}

# ── App ───────────────────────────────────────────────────────────────────────
ENV_NAME=development
CORS_ORIGINS=http://localhost:3000,http://localhost:8080
DOCS_URL=/docs
REDOC_URL=/redoc
EOF

chmod 600 "$ENV_FILE"
log "Done. .env written with live RDS credentials."
