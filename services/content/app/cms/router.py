"""CMS router — all /api/v1/cms endpoints.

Responsible for HTTP concerns only: methods, status codes, response_model,
dependencies. Zero business logic — delegates entirely to controller.
"""

from uuid import UUID

from fastapi import APIRouter, BackgroundTasks, Depends, Query, status
from sqlalchemy.ext.asyncio import AsyncSession

from redis.asyncio import Redis

from app.config import Settings
from app.database import get_db
from app.dependencies import get_current_user, get_opensearch, get_optional_user, get_redis, get_settings
from app.search.indexer import delete_post_from_opensearch, sync_post_to_opensearch
from app.cms import controller
from app.cms.schemas import (
    ChannelResponse,
    CreateChannelRequest,
    CreatePostRequest,
    PostListResponse,
    PostResponse,
    PostRestoreRequest,
    PostVersionResponse,
    UpdateChannelRequest,
    UpdatePostRequest,
)

router = APIRouter(prefix="/cms", tags=["CMS"])

_404 = {"description": "Not found"}
_403 = {"description": "Forbidden — not the author or owner"}
_409 = {"description": "Conflict — duplicate slug or already in target state"}
_422 = {"description": "Validation error or invalid state transition"}


# ---------------------------------------------------------------------------
# Post endpoints
# ---------------------------------------------------------------------------


@router.post(
    "/posts",
    response_model=PostResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create a post",
    description=(
        "Create a TEXT, IMAGE, VIDEO, or LINK post. "
        "Pass `status=PUBLISHED` to publish immediately, or omit/pass `DRAFT` to save as draft. "
        "WEBINAR_CARD and COURSE_CARD are auto-generated by other services."
    ),
    responses={422: _422},
)
async def create_post(
    payload: CreatePostRequest,
    author_id: UUID = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
    redis: Redis = Depends(get_redis),
) -> PostResponse:
    return await controller.create_post(payload, author_id, db, redis=redis)


@router.get(
    "/posts/{post_id}",
    response_model=PostResponse,
    summary="Get a post by ID",
    description=(
        "Returns the post if visible to the caller. "
        "DRAFT posts are only visible to their author. "
        "PUBLISHED and EDITED posts are public (no auth needed). "
        "SOFT_DELETED and HIDDEN_BY_ADMIN are visible only to the author (shows the status)."
    ),
    responses={404: _404},
)
async def get_post(
    post_id: UUID,
    viewer_id: UUID | None = Depends(get_optional_user),
    db: AsyncSession = Depends(get_db),
) -> PostResponse:
    return await controller.get_post(post_id, viewer_id, db)


@router.patch(
    "/posts/{post_id}",
    response_model=PostResponse,
    summary="Edit a post",
    description=(
        "Partially update a DRAFT, PUBLISHED, or EDITED post. "
        "Only the author can edit. "
        "Editing a PUBLISHED post automatically snapshots the previous version "
        "and transitions status to EDITED."
    ),
    responses={404: _404, 403: _403, 422: _422},
)
async def update_post(
    post_id: UUID,
    payload: UpdatePostRequest,
    background_tasks: BackgroundTasks,
    author_id: UUID = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
    os_client=Depends(get_opensearch),
    settings: Settings = Depends(get_settings),
) -> PostResponse:
    response = await controller.update_post(post_id, payload, author_id, db)
    # Re-index the updated post in OpenSearch (non-blocking)
    if os_client is not None:
        background_tasks.add_task(
            sync_post_to_opensearch, response, os_client, settings.opensearch_index_prefix
        )
    return response


@router.delete(
    "/posts/{post_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Soft delete a post",
    description=(
        "Transitions the post to SOFT_DELETED. Data is retained for 30 days. "
        "The author can restore within this window. Only the author can delete."
    ),
    responses={404: _404, 403: _403},
)
async def delete_post(
    post_id: UUID,
    background_tasks: BackgroundTasks,
    author_id: UUID = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
    os_client=Depends(get_opensearch),
    settings: Settings = Depends(get_settings),
) -> None:
    await controller.delete_post(post_id, author_id, db)
    # Remove from OpenSearch index (non-blocking)
    if os_client is not None:
        background_tasks.add_task(
            delete_post_from_opensearch, post_id, os_client, settings.opensearch_index_prefix
        )


@router.post(
    "/posts/{post_id}/publish",
    response_model=PostResponse,
    summary="Publish a draft post",
    description=(
        "Transitions a DRAFT post to PUBLISHED. "
        "Only the author can publish. Only DRAFT posts are eligible."
    ),
    responses={404: _404, 403: _403, 422: _422},
)
async def publish_post(
    post_id: UUID,
    background_tasks: BackgroundTasks,
    author_id: UUID = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
    os_client=Depends(get_opensearch),
    settings: Settings = Depends(get_settings),
) -> PostResponse:
    response = await controller.publish_post(post_id, author_id, db)
    # Index the newly published post in OpenSearch (non-blocking)
    if os_client is not None:
        background_tasks.add_task(
            sync_post_to_opensearch, response, os_client, settings.opensearch_index_prefix
        )
    return response


@router.post(
    "/posts/{post_id}/hide",
    response_model=PostResponse,
    summary="Hide a post (admin action)",
    description=(
        "Transitions the post to HIDDEN_BY_ADMIN. "
        "The author sees a 'hidden' status and can appeal via the report flow. "
        "Admin RBAC is enforced at the API gateway level."
    ),
    responses={404: _404},
)
async def hide_post(
    post_id: UUID,
    _: UUID = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
) -> PostResponse:
    return await controller.hide_post(post_id, db)


@router.get(
    "/posts/{post_id}/versions",
    response_model=list[PostVersionResponse],
    summary="List edit history for a post",
    description=(
        "Returns all version snapshots taken before each edit, newest first. "
        "Author-only. Use the returned `version_number` with the restore endpoint."
    ),
    responses={404: _404, 403: _403},
)
async def get_post_versions(
    post_id: UUID,
    author_id: UUID = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
) -> list[PostVersionResponse]:
    return await controller.get_post_versions(post_id, author_id, db)


@router.post(
    "/posts/{post_id}/restore",
    response_model=PostResponse,
    summary="Restore a historical version",
    description=(
        "Restores the post to the specified historical version snapshot. "
        "The current state is snapshotted first before the restore is applied. "
        "Author-only."
    ),
    responses={404: _404, 403: _403},
)
async def restore_post_version(
    post_id: UUID,
    payload: PostRestoreRequest,
    author_id: UUID = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
) -> PostResponse:
    return await controller.restore_post_version(post_id, payload, author_id, db)


@router.get(
    "/my-posts",
    response_model=PostListResponse,
    summary="List my posts",
    description=(
        "Returns all posts by the authenticated user (any status), "
        "cursor-paginated newest first. "
        "Pass the `cursor` value from a previous response to get the next page."
    ),
)
async def get_my_posts(
    cursor: str | None = Query(default=None, description="Opaque cursor from a previous response."),
    limit: int = Query(default=20, ge=1, le=100, description="Items per page."),
    author_id: UUID = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
) -> PostListResponse:
    return await controller.get_my_posts(author_id, db, cursor=cursor, limit=limit)


# ---------------------------------------------------------------------------
# Channel endpoints
# ---------------------------------------------------------------------------


@router.post(
    "/channels",
    response_model=ChannelResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create a channel",
    description=(
        "Create a new content channel. The authenticated user becomes the owner. "
        "Slug is auto-generated from the name if not provided."
    ),
    responses={409: _409},
)
async def create_channel(
    payload: CreateChannelRequest,
    owner_id: UUID = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
) -> ChannelResponse:
    return await controller.create_channel(payload, owner_id, db)


@router.get(
    "/channels",
    response_model=list[ChannelResponse],
    summary="List active channels",
    description="Returns paginated list of all active channels.",
)
async def list_channels(
    limit: int = Query(default=20, ge=1, le=100),
    offset: int = Query(default=0, ge=0),
    db: AsyncSession = Depends(get_db),
) -> list[ChannelResponse]:
    return await controller.list_channels(db, limit=limit, offset=offset)


@router.get(
    "/channels/{channel_id}",
    response_model=ChannelResponse,
    summary="Get a channel by ID",
    responses={404: _404},
)
async def get_channel(
    channel_id: UUID,
    db: AsyncSession = Depends(get_db),
) -> ChannelResponse:
    return await controller.get_channel(channel_id, db)


@router.patch(
    "/channels/{channel_id}",
    response_model=ChannelResponse,
    summary="Update a channel",
    description="Owner-only. Updates name, description, logo URL, or active status.",
    responses={404: _404, 403: _403},
)
async def update_channel(
    channel_id: UUID,
    payload: UpdateChannelRequest,
    owner_id: UUID = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
) -> ChannelResponse:
    return await controller.update_channel(channel_id, payload, owner_id, db)


@router.delete(
    "/channels/{channel_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Deactivate a channel",
    description="Sets `is_active=false`. Posts are retained. Owner-only.",
    responses={404: _404, 403: _403},
)
async def deactivate_channel(
    channel_id: UUID,
    owner_id: UUID = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
) -> None:
    await controller.update_channel(channel_id, UpdateChannelRequest(is_active=False), owner_id, db)
